<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Spotify Pauser</title>
    <style>
      :root {
        --bg: #0f1115;
        --panel: #161922;
        --text: #e8ecf1;
        --muted: #a7b0bd;
        --accent: #1db954;
        --danger: #ff5c70;
        --shadow: 0 10px 30px rgba(0,0,0,0.35);
      }

      html, body {
        height: 100%;
        margin: 0;
        background: radial-gradient(1200px 600px at 70% -20%, #1a2030, var(--bg));
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .container {
        max-width: 760px;
        margin: 0 auto;
        padding: 28px 18px 60px;
      }

      header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 22px;
      }

      .cover {
        width: 64px;
        height: 64px;
        border-radius: 8px;
        background: #23293a;
        box-shadow: var(--shadow);
        object-fit: cover;
      }

      .titles {
        flex: 1;
        min-width: 0;
      }

      .now-title {
        font-weight: 700;
        font-size: 18px;
        line-height: 1.2;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .now-subtitle {
        color: var(--muted);
        font-size: 14px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .panel {
        background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
        border: 1px solid rgba(255,255,255,0.06);
        border-radius: 16px;
        padding: 18px;
        box-shadow: var(--shadow);
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr;
        gap: 16px;
        align-items: center;
        justify-items: center;
        text-align: center;
      }

      .big-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        width: 220px;
        height: 220px;
        border-radius: 50%;
        font-weight: 800;
        letter-spacing: 0.5px;
        color: #09110c;
        background: radial-gradient(400px 200px at 50% -10%, #4ee07e, var(--accent));
        border: none;
        cursor: pointer;
        box-shadow: 0 20px 50px rgba(29,185,84,0.35), inset 0 2px 10px rgba(255,255,255,0.25);
        outline: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        transition: transform 120ms ease, filter 120ms ease;
        --icon-size: 88px;
      }
      .btn-icon { line-height: 1; }
      .btn-icon svg { width: var(--icon-size); height: var(--icon-size); display: block; fill: currentColor; }
      .now-subtitle svg { width: 14px; height: 14px; vertical-align: -2px; fill: currentColor; }
      .btn-count { font-size: calc(var(--icon-size) * 0.8); line-height: 1; }
      .big-btn:active { transform: translateY(2px) scale(0.99); filter: brightness(0.98); }
      .big-sub {
        font-size: 18px;
        font-weight: 700;
        margin-top: 8px;
        color: var(--muted);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 16px;
        width: 100%;
      }

      .field {
        display: flex;
        align-items: center;
        gap: 10px;
        justify-content: center;
      }
      .field label { color: var(--muted); font-weight: 600; }
      .field input[type="number"] {
        width: 96px;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.12);
        background: #0e1320;
        color: var(--text);
        font-weight: 700;
        text-align: center;
      }
      .field input[type="checkbox"] { transform: scale(1.2); }

      .hint { color: var(--muted); font-size: 13px; text-align: center; }
      .status { text-align: center; color: var(--muted); margin-top: 10px; min-height: 20px; }
      .error { color: var(--danger); }

      .auth {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin: 20px 0 10px;
      }
      /* Intro panel text layout */
      .intro { padding-top: 32px; }
      .intro p { max-width: 480px; margin: 0 auto 16px; }
      .intro p:first-of-type { font-weight: 700; }
      .intro .status { max-width: 480px; margin: 14px auto 0; }
      .btn {
        padding: 10px 14px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.12);
        background: #0e1320;
        color: var(--text);
        cursor: pointer;
        font-weight: 700;
      }
      .btn.accent { background: var(--accent); color: #09110c; border: none; }

      .upnext { text-align: center; margin-top: 8px; color: var(--muted); display:none; }

      footer { text-align: center; margin-top: 36px; color: var(--muted); font-size: 12px; }
      a { color: var(--accent); text-decoration: none; }

      @media (max-width: 420px) {
        .big-btn { width: 180px; height: 180px; --icon-size: 72px; }
        .big-sub { font-size: 16px; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header id="appHeader" style="display:none;">
        <img id="cover" class="cover" alt="cover" />
        <div class="titles">
          <div id="nowTitle" class="now-title">Not playing</div>
          <div id="nowSubtitle" class="now-subtitle">—</div>
        </div>
      </header>

      <div id="appControls" class="panel controls" style="display:none;">
        <button id="toggleBtn" class="big-btn" title="Play/Pause"><div class="btn-icon"><svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l11-7z"></path></svg></div></button>
        <div id="bigSub" class="big-sub">Ready</div>

        <div class="grid">
          <div class="field">
            <label for="delay">Delay between songs</label>
            <input id="delay" type="number" min="0" step="1" value="10" />
            <span>sec</span>
          </div>
          <div class="field">
            <input id="permanent" type="checkbox" />
            <label for="permanent">Pause permanently</label>
          </div>
        </div>

        <div id="upnext" class="upnext"></div>
        <div id="status" class="status"></div>
        <div class="auth">
          <button id="fullscreenBtn" class="btn" style="display:none">Fullscreen</button>
          <button id="logoutBtn" class="btn" style="display:none">Sign out</button>
        </div>
      </div>

      <div id="intro" class="panel intro" style="display:block;">
        <p>
          Pauser allows you to pause a Spotify playlist for a desired amount of time between songs, useful for example for dance playlists.
        </p>
        <p>
          Use Spotify to play playlists normally, and keep Pauser open in a browser window. On mobile keep the browser open and display on.
        </p>
        <p>
          Spotify restricts publishing apps using the API, so you need to create your own Spotify Client ID and add your Spotify account as a test user to use Pauser. See instructions on
          <a href="https://github.com/plaa/SpotifyPauser" target="_blank" rel="noopener">GitHub</a>.
        </p>
        <div class="field" style="justify-content:center; gap:10px; margin-top:16px;">
          <label for="clientIdInput"><strong>Client ID</strong></label>
          <input id="clientIdInput" type="text" inputmode="latin" autocomplete="off" spellcheck="false" placeholder="11223344556677889900aabbccddeeff" style="width:340px; text-align:left;" />
        </div>
        <div style="text-align:center; margin-top:16px;">
          <button id="loginBtn" class="btn accent">Connect to Spotify</button>
        </div>
        <div id="statusIntro" class="status" aria-live="polite"></div>
      </div>

      <footer>
        Runs entirely in your browser and only communicates with Spotify. Source: <a href="https://github.com/plaa/SpotifyPauser" target="_blank" rel="noopener">GitHub</a>
      </footer>
    </div>

    <script>
      // ----- Config -----
      let CLIENT_ID = null; // set from user input or saved prefs
      const REDIRECT_URI = window.location.origin + window.location.pathname;
      const SCOPES = [
        'user-read-playback-state',
        'user-modify-playback-state',
        'user-read-currently-playing'
      ];
      // Inline SVG icons to avoid platform emoji styling
      const ICON_PLAY = '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5v14l11-7z"></path></svg>';
      const ICON_PAUSE = '<svg viewBox="0 0 24 24" aria-hidden="true"><rect x="6" y="5" width="4" height="14"></rect><rect x="14" y="5" width="4" height="14"></rect></svg>';
      function createIconSVG(type, size = 14) {
        const ns = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(ns, 'svg');
        svg.setAttribute('viewBox', '0 0 24 24');
        svg.setAttribute('aria-hidden', 'true');
        svg.style.width = size + 'px';
        svg.style.height = size + 'px';
        svg.style.fill = 'currentColor';
        if (type === 'play') {
          const p = document.createElementNS(ns, 'path');
          p.setAttribute('d', 'M8 5v14l11-7z');
          svg.appendChild(p);
        } else {
          const r1 = document.createElementNS(ns, 'rect');
          r1.setAttribute('x', '6'); r1.setAttribute('y', '5'); r1.setAttribute('width', '4'); r1.setAttribute('height', '14');
          const r2 = document.createElementNS(ns, 'rect');
          r2.setAttribute('x', '14'); r2.setAttribute('y', '5'); r2.setAttribute('width', '4'); r2.setAttribute('height', '14');
          svg.appendChild(r1); svg.appendChild(r2);
        }
        return svg;
      }

      // ----- State -----
      const els = {
        cover: document.getElementById('cover'),
        nowTitle: document.getElementById('nowTitle'),
        nowSubtitle: document.getElementById('nowSubtitle'),
        toggleBtn: document.getElementById('toggleBtn'),
        bigSub: document.getElementById('bigSub'),
        delay: document.getElementById('delay'),
        permanent: document.getElementById('permanent'),
        upnext: document.getElementById('upnext'),
        status: document.getElementById('status'),
        loginBtn: document.getElementById('loginBtn'),
        logoutBtn: document.getElementById('logoutBtn'),
        fullscreenBtn: document.getElementById('fullscreenBtn')
      };


      let token = null; // { access_token, refresh_token, expires_at }
      let refreshTimer = null;
      let pollTimer = null;
      let pauseScheduleTimer = null;
      let countdownTimer = null;
      let inBetweenPause = false;
      let resumeAt = null;
      let upNextCache = null; // cache next queue item during pause

      // Preference keys
      const PREF_DELAY_SECS = 'sp_pref_delay_secs';
      const PREF_PERMANENT = 'sp_pref_permanent';
      const PREF_CLIENT_ID = 'sp_client_id';

      function loadPrefs() {
        const delayRaw = localStorage.getItem(PREF_DELAY_SECS);
        const permRaw = localStorage.getItem(PREF_PERMANENT);
        const delay = Number.parseInt(delayRaw ?? '', 10);
        const permanent = permRaw === '1' || permRaw === 'true';
        if (Number.isFinite(delay) && delay >= 0) {
          els.delay.value = String(delay);
        }
        els.permanent.checked = permanent;
        els.delay.disabled = permanent;
      }

      function saveDelayPref() {
        const n = getDelaySec();
        localStorage.setItem(PREF_DELAY_SECS, String(n));
      }
      function savePermanentPref() {
        localStorage.setItem(PREF_PERMANENT, els.permanent.checked ? '1' : '0');
      }

      function setSignedInUI(on) {
        document.getElementById('appHeader').style.display = on ? 'flex' : 'none';
        document.getElementById('appControls').style.display = on ? 'grid' : 'none';
        document.getElementById('intro').style.display = on ? 'none' : 'block';
        if (els.fullscreenBtn) els.fullscreenBtn.style.display = on ? 'inline-block' : 'none';
      }

      function isValidClientId(s) {
        return typeof s === 'string' && /^[A-Za-z0-9]{1,50}$/.test(s);
      }

      function loadClientId() {
        const saved = localStorage.getItem(PREF_CLIENT_ID);
        if (isValidClientId(saved)) CLIENT_ID = saved;
        // Prefill from ?id= if valid
        const p = new URLSearchParams(window.location.search).get('id');
        if (isValidClientId(p)) {
          const input = document.getElementById('clientIdInput');
          if (input) input.value = p;
        } else if (!saved) {
          // if nothing saved, leave placeholder
        } else {
          const input = document.getElementById('clientIdInput');
          if (input) input.value = saved;
        }
      }

      // ----- Utils -----
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));
      function msToClock(ms) {
        const s = Math.max(0, Math.floor(ms / 1000));
        const m = Math.floor(s / 60);
        const ss = String(s % 60).padStart(2, '0');
        return `${m}:${ss}`;
      }
      function artistsToString(artists) { return (artists || []).map(a => a.name).join(', '); }
      function saveToken(t) {
        token = t;
        localStorage.setItem('sp_token', JSON.stringify(t));
        els.logoutBtn.style.display = 'inline-block';
        els.loginBtn.style.display = 'none';
      }
      function loadToken() {
        const raw = localStorage.getItem('sp_token');
        if (!raw) return null;
        try { return JSON.parse(raw); } catch { return null; }
      }

      // ----- PKCE Auth -----
      function base64url(uint8Arr) {
        let str = btoa(String.fromCharCode(...new Uint8Array(uint8Arr)));
        return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/,'');
      }
      function randomString(len = 64) {
        const bytes = new Uint8Array(len);
        crypto.getRandomValues(bytes);
        return Array.from(bytes).map(b => ('0'+b.toString(16)).slice(-2)).join('');
      }
      async function sha256(str) {
        const enc = new TextEncoder();
        const data = enc.encode(str);
        return await crypto.subtle.digest('SHA-256', data);
      }
      async function startAuth() {
        const input = document.getElementById('clientIdInput');
        const candidate = input?.value?.trim();
        if (!isValidClientId(candidate) && !isValidClientId(CLIENT_ID)) {
          const msg = 'Please enter a valid Client ID (alphanumeric, 1–50 chars).';
          const sIntro = document.getElementById('statusIntro');
          if (sIntro) { sIntro.textContent = msg; sIntro.classList.add('error'); }
          else setStatus(msg, true);
          return;
        }
        CLIENT_ID = isValidClientId(candidate) ? candidate : CLIENT_ID;
        localStorage.setItem(PREF_CLIENT_ID, CLIENT_ID);
        const codeVerifier = randomString(64);
        const codeChallenge = base64url(await sha256(codeVerifier));
        const state = randomString(16);
        sessionStorage.setItem('sp_code_verifier', codeVerifier);
        sessionStorage.setItem('sp_state', state);
        sessionStorage.setItem('sp_client_id', CLIENT_ID);
        const params = new URLSearchParams({
          client_id: CLIENT_ID,
          response_type: 'code',
          redirect_uri: REDIRECT_URI,
          code_challenge_method: 'S256',
          code_challenge: codeChallenge,
          scope: SCOPES.join(' '),
          state
        });
        window.location.assign(`https://accounts.spotify.com/authorize?${params}`);
      }
      async function exchangeCodeForToken(code) {
        const code_verifier = sessionStorage.getItem('sp_code_verifier');
        const cid = sessionStorage.getItem('sp_client_id') || localStorage.getItem(PREF_CLIENT_ID);
        if (!isValidClientId(cid)) throw new Error('Missing client id');
        CLIENT_ID = cid;
        const stateExpected = sessionStorage.getItem('sp_state');
        const stateReceived = new URL(window.location.href).searchParams.get('state');
        if (stateExpected && stateReceived && stateExpected !== stateReceived) throw new Error('Invalid state');
        const body = new URLSearchParams({
          client_id: CLIENT_ID,
          grant_type: 'authorization_code',
          code,
          redirect_uri: REDIRECT_URI,
          code_verifier
        });
        const res = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body
        });
        if (!res.ok) throw new Error('Token exchange failed');
        const data = await res.json();
        const expires_at = Date.now() + (data.expires_in - 10) * 1000; // safety buffer
        saveToken({ access_token: data.access_token, refresh_token: data.refresh_token, expires_at });
        scheduleRefresh();
      }
      async function refreshToken() {
        if (!token?.refresh_token) return;
        const cid = CLIENT_ID || localStorage.getItem(PREF_CLIENT_ID) || sessionStorage.getItem('sp_client_id');
        if (!isValidClientId(cid)) return;
        CLIENT_ID = cid;
        const body = new URLSearchParams({
          client_id: CLIENT_ID,
          grant_type: 'refresh_token',
          refresh_token: token.refresh_token,
        });
        const res = await fetch('https://accounts.spotify.com/api/token', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body
        });
        if (!res.ok) {
          setStatus('Token refresh failed. Please connect again.', true);
          return;
        }
        const data = await res.json();
        const expires_at = Date.now() + (data.expires_in - 10) * 1000;
        const refresh_token = data.refresh_token || token.refresh_token; // sometimes not returned
        saveToken({ access_token: data.access_token, refresh_token, expires_at });
        scheduleRefresh();
      }
      function scheduleRefresh() {
        if (!token) return;
        if (refreshTimer) clearTimeout(refreshTimer);
        const ms = Math.max(5_000, token.expires_at - Date.now() - 60_000); // 1 min prior
        refreshTimer = setTimeout(refreshToken, ms);
      }
      async function getAccessToken() {
        if (!token) return null;
        if (Date.now() > (token.expires_at - 60_000)) {
          await refreshToken();
        }
        return token?.access_token || null;
      }

      // ----- Spotify API helpers -----
      async function apiFetch(path, options = {}) {
        const at = await getAccessToken();
        if (!at) throw new Error('Not authorized');
        const res = await fetch(`https://api.spotify.com/v1${path}`, {
          ...options,
          headers: { 'Authorization': `Bearer ${at}`, 'Content-Type': 'application/json', ...(options.headers||{}) }
        });
        if (res.status === 204) return null;
        if (!res.ok) throw new Error(`API ${res.status}`);
        return res.json();
      }
      async function getPlayback() { return apiFetch('/me/player'); }
      async function pausePlayback() { try { await apiFetch('/me/player/pause', { method: 'PUT' }); } catch (e) { /* ignore */ } }
      async function startPlayback() { try { await apiFetch('/me/player/play', { method: 'PUT' }); } catch (e) { /* ignore */ } }
      async function getQueue() { return apiFetch('/me/player/queue'); }

      // ----- UI / State handling -----
      function setStatus(msg, isErr = false) {
        els.status.textContent = msg || '';
        els.status.classList.toggle('error', !!isErr);
      }
      function setBigButton(icon, sub, countText = null) {
        const countHtml = countText ? `<div class="btn-count">${countText}</div>` : '';
        els.toggleBtn.innerHTML = `<div class="btn-icon">${icon}</div>${countHtml}`;
        els.bigSub.textContent = sub || '';
      }
      function setUpcoming(text) {
        els.upnext.textContent = text || '';
      }
      function setNowPlaying(item, progress_ms, is_playing) {
        if (!item) {
          els.cover.src = '';
          els.cover.style.visibility = 'hidden';
          els.nowTitle.textContent = 'Not playing';
          els.nowSubtitle.textContent = '—';
          return;
        }
        els.cover.style.visibility = 'visible';
        const art = item.album?.images?.[1]?.url || item.album?.images?.[0]?.url;
        els.cover.src = art || '';
        els.nowTitle.textContent = item.name || 'Unknown';
        const remain = item.duration_ms - (progress_ms || 0);
        const artists = artistsToString(item.artists);
        // Build subtitle with SVG icon without using innerHTML to keep text safe
        els.nowSubtitle.textContent = '';
        els.nowSubtitle.append(document.createTextNode(`${artists} • ${msToClock(item.duration_ms)} • `));
        els.nowSubtitle.appendChild(createIconSVG(is_playing ? 'play' : 'pause', 14));
        els.nowSubtitle.append(document.createTextNode(` ${msToClock(remain)} left`));
      }

      function setHeaderToUpcoming() {
        const nxt = upNextCache;
        if (!nxt) return;
        els.cover.style.visibility = 'visible';
        const art = nxt.album?.images?.[1]?.url || nxt.album?.images?.[0]?.url;
        els.cover.src = art || '';
        els.nowTitle.textContent = nxt.name || 'Unknown';
        const artists = artistsToString(nxt.artists);
        // Indicate it's the next track but show it prominently
        els.nowSubtitle.textContent = `${artists} • ⏭ Up next`;
      }

      function getDelaySec() {
        const n = parseInt(els.delay.value, 10);
        return Number.isFinite(n) && n >= 0 ? n : 0;
      }

      function schedulePollIn(ms) {
        if (pollTimer) clearTimeout(pollTimer);
        pollTimer = setTimeout(pollLoop, ms);
      }

      async function resumePlaybackNow() {
        try {
          await startPlayback();
        } finally {
          inBetweenPause = false;
          stopCountdown();
          setBigButton(ICON_PAUSE, 'Playing');
          // Schedule a quick poll to refresh UI/state shortly after resume
          schedulePollIn(1000);
        }
      }

      function startCountdown() {
        stopCountdown();
        countdownTimer = setInterval(async () => {
          if (!inBetweenPause) return stopCountdown();
          if (els.permanent.checked) {
            setBigButton(ICON_PAUSE, 'Paused');
            return;
          }
          const ms = Math.max(0, (resumeAt || 0) - Date.now());
          const s = Math.ceil(ms / 1000);
          setBigButton(ICON_PLAY, 'Resuming soon', String(s));
          if (ms <= 0) {
            await resumePlaybackNow();
          }
        }, 200);
      }
      function stopCountdown() {
        if (countdownTimer) clearInterval(countdownTimer);
        countdownTimer = null;
      }

      function clearPauseSchedule() { if (pauseScheduleTimer) clearTimeout(pauseScheduleTimer); pauseScheduleTimer = null; }

      async function schedulePauseIfNeeded(playback) {
        clearPauseSchedule();
        const item = playback?.item;
        const progress = playback?.progress_ms ?? 0;
        const duration = item?.duration_ms ?? 0;
        const remaining = Math.max(0, duration - progress);
        if (!item || !playback?.is_playing) return;

        // If remaining time is short, plan a precise pause just before the track ends.
        if (remaining <= 15_000) {
          const triggerIn = Math.max(120, remaining - 700); // try ~0.7s before end
          pauseScheduleTimer = setTimeout(async () => {
            try {
              await pausePlayback();
              inBetweenPause = true;
              if (!els.permanent.checked) {
                resumeAt = Date.now() + getDelaySec() * 1000;
              } else {
                resumeAt = null;
              }
              startCountdown();
              // Immediately refresh upcoming using current playback context to avoid showing next-to-next
              let pb2 = null;
              try { pb2 = await getPlayback(); } catch {}
              await updateUpcoming(pb2 || undefined);
              if (upNextCache) setHeaderToUpcoming();
              // Refresh state shortly after pausing
              schedulePollIn(1000);
            } catch (e) {
              // ignore
            }
          }, triggerIn);
        }
      }

      async function updateUpcoming(playbackCtx = null) {
        try {
          const q = await getQueue();
          const nxt = q?.queue?.[0] || null;
          let candidate = nxt;
          if (inBetweenPause && playbackCtx?.item) {
            const atStart = (playbackCtx.progress_ms ?? 0) <= 3000; // within first 3s
            if (atStart) candidate = playbackCtx.item; // Spotify already advanced to next and paused at start
          }
          upNextCache = candidate || null;
          // Hide separate 'up next' text; show in header during pause instead
          setUpcoming('');
          if (inBetweenPause && upNextCache) setHeaderToUpcoming();
        } catch {
          upNextCache = null;
          setUpcoming('');
        }
      }

      async function pollOnce() {
        if (!token) return;
        try {
          const playback = await getPlayback();
          if (!playback) {
            setStatus('No active device. Start Spotify on a device.');
            setNowPlaying(null);
            setBigButton(ICON_PLAY, 'Ready');
            inBetweenPause = false;
            stopCountdown();
            return 5_000;
          }

          const { is_playing, item, progress_ms } = playback;
          if (inBetweenPause && upNextCache) {
            setHeaderToUpcoming();
          } else {
            setNowPlaying(item, progress_ms, is_playing);
          }

          if (is_playing) {
            // Normal play: ensure UI shows Pause icon
            setBigButton(ICON_PAUSE, 'Playing');
            inBetweenPause = false;
            stopCountdown();
            await schedulePauseIfNeeded(playback);
          } else {
            // Paused. If we're in between songs (we paused), handle resume.
            if (inBetweenPause) {
              // Keep countdown fresh and show next on header.
              startCountdown();
              await updateUpcoming(playback);
              if (upNextCache) setHeaderToUpcoming();
            } else {
              // User manually paused; reflect state.
              setBigButton(ICON_PLAY, 'Paused');
            }
          }

          // Fixed-interval polling
          return 5_000;
        } catch (e) {
          setStatus('Playback check failed. Retrying…');
          return 5_000;
        }
      }

      async function pollLoop() {
        if (pollTimer) clearTimeout(pollTimer);
        const nextIn = await pollOnce();
        pollTimer = setTimeout(pollLoop, nextIn);
      }

      // ----- Events -----
      els.loginBtn.addEventListener('click', startAuth);
      els.logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('sp_token');
        token = null;
        if (refreshTimer) clearTimeout(refreshTimer);
        if (pollTimer) clearTimeout(pollTimer);
        clearPauseSchedule();
        stopCountdown();
        setStatus('Signed out.');
        els.logoutBtn.style.display = 'none';
        setSignedInUI(false);
        setBigButton(ICON_PLAY, 'Ready');
      });
      function isFullscreen() { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement); }
      function updateFullscreenBtnLabel() {
        if (!els.fullscreenBtn) return;
        els.fullscreenBtn.textContent = isFullscreen() ? 'Exit Fullscreen' : 'Fullscreen';
      }
      async function toggleFullscreen() {
        try {
          if (!isFullscreen()) {
            const el = document.documentElement;
            if (el.requestFullscreen) await el.requestFullscreen();
            else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
            else if (el.msRequestFullscreen) await el.msRequestFullscreen();
          } else {
            if (document.exitFullscreen) await document.exitFullscreen();
            else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
            else if (document.msExitFullscreen) await document.msExitFullscreen();
          }
        } catch (e) {
          setStatus('Fullscreen not available.', true);
        } finally {
          updateFullscreenBtnLabel();
        }
      }
      if (els.fullscreenBtn) {
        els.fullscreenBtn.addEventListener('click', toggleFullscreen);
        document.addEventListener('fullscreenchange', updateFullscreenBtnLabel);
        document.addEventListener('webkitfullscreenchange', updateFullscreenBtnLabel);
        document.addEventListener('msfullscreenchange', updateFullscreenBtnLabel);
      }
      els.permanent.addEventListener('change', () => {
        els.delay.disabled = els.permanent.checked;
        savePermanentPref();
      });
      els.delay.addEventListener('change', () => {
        // Normalize and persist
        const n = getDelaySec();
        els.delay.value = String(n);
        saveDelayPref();
      });
      els.toggleBtn.addEventListener('click', async () => {
        try {
          const playback = await getPlayback();
          if (!playback) return;
          if (inBetweenPause) {
            // If in scheduled pause, act as immediate resume
            await startPlayback();
            inBetweenPause = false;
            stopCountdown();
            setBigButton(ICON_PAUSE, 'Playing');
            schedulePollIn(1000);
            return;
          }
          if (playback.is_playing) {
            await pausePlayback();
              setBigButton(ICON_PLAY, 'Paused');
          } else {
            await startPlayback();
            setBigButton(ICON_PAUSE, 'Playing');
          }
          schedulePollIn(1000);
        } catch (e) {
          setStatus('Action failed. Ensure Spotify is open.', true);
        }
      });

      // ----- Init -----
      (async function init() {
        // Load client id preference and prefill
        loadClientId();

        // Handle auth redirect
        const params = new URLSearchParams(window.location.search);
        const code = params.get('code');
        const error = params.get('error');
        if (error) {
          setStatus('Authorization failed: ' + error, true);
        }
        if (code) {
          try {
            await exchangeCodeForToken(code);
            // Cleanup URL
            history.replaceState({}, document.title, REDIRECT_URI);
          } catch (e) {
            setStatus('Token exchange failed.', true);
          }
        } else {
          // Load any existing token
          const saved = loadToken();
          if (saved) {
            saveToken(saved);
            scheduleRefresh();
          }
        }

        // Load and apply user preferences for delay/permanent pause
        loadPrefs();

        if (token) {
          setStatus('Connected.');
          setSignedInUI(true);
          pollLoop();
        } else {
          setStatus('Connect to Spotify to begin.');
          setSignedInUI(false);
          els.logoutBtn.style.display = 'none';
        }
      })();
    </script>
  </body>
</html>
